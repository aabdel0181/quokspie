#include <iostream>
#include <string.h>
#include <nvml.h>
#include "../build/Enclave_t.h" // Generated by SGX EDL compiler
#include <openssl/hmac.h>
#include <openssl/evp.h>

// implement ocall
void enclavePrintf(char *str) {
    printf("%s\n", str); // Use untrusted printf to display the message
}


void getDeviceHandles(unsigned int tk, uintptr_t *handles, unsigned int *handleCount) {
    unsigned int numDevices = 0;
    nvmlReturn_t result;

    // Initialize NVML
    result = nvmlInit();
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to initialize NVML: " << nvmlErrorString(result) << std::endl;
        *handleCount = 0; // Set handleCount to 0 on failure
        return;
    }
    std::cout << "NVML initialized successfully." << std::endl;

    // Get the number of devices
    result = nvmlDeviceGetCount(&numDevices);
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to get device count: " << nvmlErrorString(result) << std::endl;
        *handleCount = 0; // Set handleCount to 0 on failure
        nvmlShutdown();
        return;
    }

    if (*handleCount < numDevices) {
        std::cerr << "Insufficient buffer size for handles. Found " << numDevices 
                  << " devices, but buffer can store only " << *handleCount << "." << std::endl;
        nvmlShutdown();
        *handleCount = 0;
        return;
    }

    // Retrieve and store device handles
    for (unsigned int i = 0; i < numDevices; i++) {
        nvmlDevice_t device;
        result = nvmlDeviceGetHandleByIndex(i, &device);
        if (result != NVML_SUCCESS) {
            std::cerr << "Failed to get device handle for device " << i 
                      << ": " << nvmlErrorString(result) << std::endl;
            handles[i] = 0; // Mark invalid handle
            continue; // Continue with next device
        }

        handles[i] = reinterpret_cast<uintptr_t>(device); // Store the handle

        
        /* TODO: GRAB UUID AND STORE IN ENCLAVE
        result = nvmlDeviceGetName(handle, name, NVML_DEVICE_NAME_V2_BUFFER_SIZE);
        if (result != NVML_SUCCESS)
        {
            std::cerr << "Failed to get device name for device " << i << ": " << nvmlErrorString(result) << std::endl;
            return;
        }
        std::cout << "Device " << i << ": " << name << std::endl;

        // Get the UUID once and store it for printing in each loop iteration
        result = nvmlDeviceGetUUID(handle, uuid, sizeof(uuid));
        if (result == NVML_SUCCESS)
        {
            std::cout << "Device UUID: " << uuid << std::endl;
        }
        else
        {
            std::cerr << "Failed to get device UUID for device " << i << ": " << nvmlErrorString(result) << std::endl;
        }
        */
    }

    char driver_version[80];
    result = nvmlSystemGetDriverVersion(driver_version, sizeof(driver_version));
    if (result == NVML_SUCCESS)
    {
        std::cout << "Driver version: " << driver_version << std::endl;
    }
    else
    {
        std::cerr << "Failed to get driver version: " << nvmlErrorString(result) << std::endl;
    }
}

//perform polling... Should bandwidth allow, run each check individually
void pollGPU(char *tk, void* handle, unsigned int *temperature,
             unsigned int *clock_speed, unsigned int *memory_used,
             unsigned int *power, unsigned char *hmac) {
    //cast pointer back to handle            
    nvmlDevice_t device = reinterpret_cast<nvmlDevice_t>(handle);
    nvmlReturn_t result;

    // Retrieve GPU metrics
    result = nvmlDeviceGetTemperature(device, NVML_TEMPERATURE_GPU, temperature);
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to get temperature: " << nvmlErrorString(result) << std::endl;
        *temperature = 0;
    }

    result = nvmlDeviceGetClockInfo(device, NVML_CLOCK_GRAPHICS, clock_speed);
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to get clock speed: " << nvmlErrorString(result) << std::endl;
        *clock_speed = 0;
    }

    nvmlMemory_t memory_info;
    result = nvmlDeviceGetMemoryInfo(device, &memory_info);
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to get memory usage: " << nvmlErrorString(result) << std::endl;
        *memory_used = 0;
    } else {
        *memory_used = memory_info.used / (1024 * 1024); // Convert bytes to MB
    }

    result = nvmlDeviceGetPowerUsage(device, power);
    if (result != NVML_SUCCESS) {
        std::cerr << "Failed to get power usage: " << nvmlErrorString(result) << std::endl;
        *power = 0;
    }

    // Compute HMAC for data integrity
    unsigned char data[128];
    size_t offset = 0;

    // Serialize data into a buffer
    memcpy(data + offset, temperature, sizeof(*temperature));
    offset += sizeof(*temperature);
    memcpy(data + offset, clock_speed, sizeof(*clock_speed));
    offset += sizeof(*clock_speed);
    memcpy(data + offset, memory_used, sizeof(*memory_used));
    offset += sizeof(*memory_used);
    memcpy(data + offset, power, sizeof(*power));
    offset += sizeof(*power);

    // Compute HMAC
    HMAC(EVP_sha256(), tk, 32, data, offset, hmac, NULL);
}