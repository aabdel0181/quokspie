#include <iostream>
#include <nvml.h>
#include <atomic>
#include "../build/Enclave_t.h" // Generated by SGX EDL compiler
#include <thread>
#include "sgx_urts.h"
#include "sgx_tcrypto.h"

#define ENCLAVE_FILENAME "enclave.signed.so"

sgx_enclave_id_t global_eid = 0;
// Global atomic flag to signal the worker thread to stop
std::atomic<bool> keep_running(true);

// Worker thread function
void gpuProberLoop() {
    while (keep_running.load()) {
        try {
            // Call ecallGetData every second
            sgx_status_t status = ecallGetData();

            if(status != SGX_SUCCESS) {
                std::cout << "ecallGetData failed!" << std::endl;
                keep_running.store(false);
            }
            // Sleep for 1 second
            std::this_thread::sleep_for(std::chrono::seconds(1));
        } catch (const std::exception &e) {
            std::cerr << "Exception in gpuProberLoop: " << e.what() << std::endl;
            keep_running.store(false); // Stop the loop if an exception occurs
        }
    }
}

void execute_workload()
{
    std::cout << "Executing our sample workload..." << std::endl;
}

//destroy enclave and shut down nvml
void cleanup() {
    sgx_destroy_enclave(global_eid);
    std::cout << "Enclave destroyed successfully." << std::endl;
    nvmlShutdown();
    std::cout << "NVML shutdown successfully." << std::endl;
}

int main()
{
    std::cout << "Starting program..." << std::endl;

    std::cout << "Initializing SGX Enclave..." << std::endl;
    
    sgx_status_t status = sgx_create_enclave(ENCLAVE_FILENAME, SGX_DEBUG_FLAG, NULL, NULL, &global_eid, NULL);
    if (status != SGX_SUCCESS) {
        std::cerr << "Failed to create enclave. Error code: " << status << std::endl;
        cleanup();
        return -1;
    }

    std::cout << "Initializing NVML thru Enclave..." << std::endl;

    status = ecallInit();

    if(status != SGX_SUCCESS) {
        std::cout << "SGX NVML failed" << std::endl;
        cleanup();
        return -1;
    }

    // Run the GPU prober in a separate thread
    std::thread odometer_thread(gpuProberLoop);
    odometer_thread.detach();

    execute_workload();

    // Keep the main thread alive to allow the odometer to run
    try
    {
        while (true)
        {
            std::this_thread::sleep_for(std::chrono::seconds(1));
        }
    }
    catch (...)
    {
        std::cerr << "Exiting..." << std::endl;
    }

    cleanup();

    std::cout << "program exited, nvml shut down, and enclave destroyed." << std::endl;
    return 0;
}